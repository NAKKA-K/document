# CLanguage Pointer

# ポインター講座

ポインターとはすごく省いてに説明すると配列と考え方はあまり変わりません。
後々、少し違うというと思いますが最初のころは同じようなものです。
`
int *pointer; //ポインター変数の作り方
`

ポインターとは普通の変数の様に直接値を入れるのではなく、アドレスという住所を使用します。
int型であれば10という数値を直接代入し、char型なら'a'という文字(0x61)を代入するといったように、直接値を代入しています。
しかしポインターは違います。

例としてC言語における値を、人間に置き換えて説明します。仮に人間の名前はうどん君として話します。
通常の変数などは、うどん君が直接横にいて、すぐに話ができる状態です。
`temp = mrUdon;`等といったようにそのまま値が使用できます。

そしてポインターとは、うどん君の住所が書いた紙を持っている状態です。書いてある住所まで行けばうどん君と話ができます。
`
int mrUdon = 0; //うどん君自身
int *pointer = &mrUdon; //&をつけることによってうどん君の住所が取り出せるので、それをポインターに保存している
`

ポインターからうどん君と話をするには
`temp = *pointer;`といったように書きます。
pointerの前に*(アスタリスク)がついていますがこれは、住所が書かれた紙を参照している、といことです。
pointerという紙に書かれた住所を*で参照して、その住所まで行ってうどん君と話すといった流れです。

`
#include<stdio.h>
int main(void){
	int mrUdon = 10;
	int *pointer;

	pointer = &mrUdon;

	printf("pointer:%d, int:%d\n", *pointer, mrUdon); //どちらも10と出るはずです
	printf("address:%d\n", pointer); //うどん君の住所が出るはずです。たぶんとんでもない数字


	//ここからは少し発展----------------------------------------------
	printf("\n発展---------------------------------------------------\n\n");


	mrUdon = 20; //うどん君の値を少し変えました

	printf("pointer:%d, int:%d", *pointer, mrUdon); //どうなりました？(両方同じ値が出るかと)
	printf("address:%d, &mrUdon:%d", pointer, &mrUdon); //うどん君の住所が出るはずです。(前回と比べて見てください)

	return 0;
}
`

-------------------------------------------------------------------------------------------------------------------------

ここからはポインターで配列を扱ってみましょう。
先ほどまでポインター変数にうどん君の住所を入れて扱っていただけでした。
しかしここで問題が発生しました。実はうどん君には離れて暮らしている兄弟がたくさんいたのです。
彼らはみんなうどん君という名前がついています。そんな時は配列を使うしかないですね！
`
int mrUdon[3] = {10,20,30};
`
彼らをポインターでつかってやりましょう。

いままでのポインターの知識では、ポインター変数を3つ作って別々に入れるという考えが浮かぶかと思います。
しかしポインターはその程度の力ではないのです。
`
int mrUdon[3] = {10,20,30};
int *pointer;
pointer = mrUdon; //普通の変数の時と少し違う書き方ですよね？
`

/* 念のため配列について解説
*  配列にアクセスするときmrUdon[0],mrUdon[1]といったように添え字でアクセスできますね。
*  ですがmrUdonとしたときに、配列の先頭のアドレス、といった意味になるのです。
*/

pointerに配列の先頭アドレスを代入しました。
これってmrUdon[0]のアドレスが入っただけだから、それしか使えないんじゃないのって思うかもしれません。
しかしポインター変数君には隠し持っていた力があるのです。
`
temp1 = *pointer; //mrUdon[0]
pointer++; //ポインター変数君を++(インクリメント)しただと！！？
temp2 = *pointer; //mrUdon[1]
`

実はプログラムレベルから見ると、配列の要素はは3000番地、3001番地といったように連続するアドレスに住んでいるのです。(変数の型によって4番地づつであったりする)
そのため配列の先頭アドレスを++すると次の要素の値が取り出せます。
もちろん++の反対で--(デクリメント)もできます。
`
temp2 = *pointer; //mrUdon[1]
pointer--;
temp = *pointer; //mrUdon[0]
`

このようにポインター変数君の値を変更していくことによって、配列でさえも扱えてしまうのです。


`
#include<stdio.h>
int main(void){
	int mrUdon[3] = {10,20,30};
	int *pointer;
	int i;

	pointer = mrUdon;


	printf("ついでにpointer:%d, mrUdon:%d, &mrUdon[0]:%d\n\n", pointer, mrUdon, &mrUdon[0]);	//ついで



	for(i = 0; i < 3; i++, pointer++){
		printf("pointer+%d:%d, int[%d]:%d\n", i, *pointer, i, mrUdon[i]); //mrUdonの要素を順番に3つ表示してくれます。
		printf("address+%d:%d\n\n", i, pointer);
	}


	//ここからは少し発展----------------------------------------------
	printf("\n発展---------------------------------------------------\n\n");

	pointer = mrUdon;

	//うどん君の値を少し変えました
	for(i = 0; i < 3; i++, pointer++){
		*pointer += 1; //今回はポインター側から値を変えてみました。
	}

	pointer = mrUdon;

	for(i = 0; i < 3; i++, pointer++){
		printf("pointer:%d, int:%d\n", *pointer, mrUdon[i]); //どうなりました？(両方同じ値が出るかと)
		printf("address+%d:%d, &mrUdon[%d]:%d\n\n", i, pointer, i, &mrUdon[i]); //うどん君の住所が出るはずです。(前回と比べて見てください)
	}


	return 0;
}
`
